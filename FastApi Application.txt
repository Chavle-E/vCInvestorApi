This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-13T22:47:58.924Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
api/
  v1/
    endpoints/
      counts.py
      export.py
      investment_funds.py
      investors.py
      lists.py
      utils.py
    dependencies.py
middleware/
  rate_limit.py
scripts/
  import_data.py
  reset_database.py
  update_schema.py
.gitignore
app.py
crud.py
database.py
deploy.py
models.py
requirements.txt
schemas.py

================================================================
Repository Files
================================================================

================
File: api/v1/endpoints/counts.py
================
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import func
from sqlalchemy.orm import Session
from typing import Optional, List
from database import get_db
import models
import schemas
import logging
from api.v1.endpoints.investors import apply_investor_filters
from api.v1.endpoints.investment_funds import apply_fund_filters

router = APIRouter()
logger = logging.getLogger(__name__)


@router.post("/investors")
async def get_investor_filter_counts(
        filters: Optional[schemas.InvestorFilterParams] = None,
        exclude_fields: List[str] = Query(default=[]),
        db: Session = Depends(get_db)
):
    """Get counts for each filter option based on current filter selections"""
    try:
        # Start with base query
        base_query = db.query(models.Investor)

        # Apply filters if provided
        if filters:
            base_query = apply_investor_filters(base_query, filters)

        counts = {}

        # Location counts
        if "location" not in exclude_fields:
            # Cities
            city_counts = (
                base_query
                .with_entities(models.Investor.city, func.count(models.Investor.id))
                .filter(models.Investor.city.isnot(None))
                .group_by(models.Investor.city)
                .all()
            )
            counts["cities"] = {city: count for city, count in city_counts if city}

            # States
            state_counts = (
                base_query
                .with_entities(models.Investor.state, func.count(models.Investor.id))
                .filter(models.Investor.state.isnot(None))
                .group_by(models.Investor.state)
                .all()
            )
            counts["states"] = {state: count for state, count in state_counts if state}

            # Countries
            country_counts = (
                base_query
                .with_entities(models.Investor.country, func.count(models.Investor.id))
                .filter(models.Investor.country.isnot(None))
                .group_by(models.Investor.country)
                .all()
            )
            counts["countries"] = {country: count for country, count in country_counts if country}

        # Industry preferences
        if "industry" not in exclude_fields:
            industry_counts = (
                base_query
                .with_entities(
                    func.unnest(models.Investor.industry_preferences).label('industry'),
                    func.count(models.Investor.id)
                )
                .filter(models.Investor.industry_preferences.isnot(None))
                .group_by('industry')
                .all()
            )
            counts["industries"] = {ind: count for ind, count in industry_counts if ind}

        # Stage preferences
        if "stages" not in exclude_fields:
            stage_counts = (
                base_query
                .with_entities(
                    func.unnest(models.Investor.stage_preferences).label('stage'),
                    func.count(models.Investor.id)
                )
                .filter(models.Investor.stage_preferences.isnot(None))
                .group_by('stage')
                .all()
            )
            counts["stages"] = {stage: count for stage, count in stage_counts if stage}

        # Fund types
        if "fundType" not in exclude_fields:
            fund_type_counts = (
                base_query
                .with_entities(models.Investor.type_of_financing, func.count(models.Investor.id))
                .filter(models.Investor.type_of_financing.isnot(None))
                .group_by(models.Investor.type_of_financing)
                .all()
            )
            counts["fundTypes"] = {ft: count for ft, count in fund_type_counts if ft}

        # Gender
        if "gender" not in exclude_fields:
            gender_counts = (
                base_query
                .with_entities(models.Investor.gender, func.count(models.Investor.id))
                .filter(models.Investor.gender.isnot(None))
                .group_by(models.Investor.gender)
                .all()
            )
            counts["genders"] = {gender: count for gender, count in gender_counts if gender}

        return counts

    except Exception as e:
        logger.error(f"Error getting investor filter counts: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/funds")
async def get_fund_filter_counts(
        filters: Optional[schemas.InvestmentFundFilterParams] = None,
        exclude_fields: List[str] = Query(default=[]),
        db: Session = Depends(get_db)
):
    """Get counts for each filter option based on current filter selections"""
    try:
        # Start with base query
        base_query = db.query(models.InvestmentFund)

        # Apply filters if provided
        if filters:
            base_query = apply_fund_filters(base_query, filters)

        counts = {}

        # Location counts
        if "location" not in exclude_fields:
            # Cities
            city_counts = (
                base_query
                .with_entities(models.InvestmentFund.firm_city, func.count(models.InvestmentFund.id))
                .filter(models.InvestmentFund.firm_city.isnot(None))
                .group_by(models.InvestmentFund.firm_city)
                .all()
            )
            counts["cities"] = {city: count for city, count in city_counts if city}

            # States
            state_counts = (
                base_query
                .with_entities(models.InvestmentFund.firm_state, func.count(models.InvestmentFund.id))
                .filter(models.InvestmentFund.firm_state.isnot(None))
                .group_by(models.InvestmentFund.firm_state)
                .all()
            )
            counts["states"] = {state: count for state, count in state_counts if state}

            # Countries
            country_counts = (
                base_query
                .with_entities(models.InvestmentFund.firm_country, func.count(models.InvestmentFund.id))
                .filter(models.InvestmentFund.firm_country.isnot(None))
                .group_by(models.InvestmentFund.firm_country)
                .all()
            )
            counts["countries"] = {country: count for country, count in country_counts if country}

        # Industry preferences
        if "industry" not in exclude_fields:
            industry_counts = (
                base_query
                .with_entities(
                    func.unnest(models.InvestmentFund.industry_preferences).label('industry'),
                    func.count(models.InvestmentFund.id)
                )
                .filter(models.InvestmentFund.industry_preferences.isnot(None))
                .group_by('industry')
                .all()
            )
            counts["industries"] = {ind: count for ind, count in industry_counts if ind}

        # Stage preferences
        if "stages" not in exclude_fields:
            stage_counts = (
                base_query
                .with_entities(
                    func.unnest(models.InvestmentFund.stage_preferences).label('stage'),
                    func.count(models.InvestmentFund.id)
                )
                .filter(models.InvestmentFund.stage_preferences.isnot(None))
                .group_by('stage')
                .all()
            )
            counts["stages"] = {stage: count for stage, count in stage_counts if stage}

        # Fund types
        if "fundType" not in exclude_fields:
            fund_type_counts = (
                base_query
                .with_entities(models.InvestmentFund.firm_type, func.count(models.InvestmentFund.id))
                .filter(models.InvestmentFund.firm_type.isnot(None))
                .group_by(models.InvestmentFund.firm_type)
                .all()
            )
            counts["fundTypes"] = {ft: count for ft, count in fund_type_counts if ft}

        return counts

    except Exception as e:
        logger.error(f"Error getting fund filter counts: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

================
File: api/v1/endpoints/export.py
================
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from database import get_db
from models import Investor, InvestmentFund
import logging
from fastapi.responses import StreamingResponse
import io
import csv

router = APIRouter()
logger = logging.getLogger(__name__)


def generate_csv(data, headers):
    """Generate CSV file from data"""
    output = io.StringIO()
    writer = csv.DictWriter(output, fieldnames=headers)
    writer.writeheader()

    for row in data:
        clean_row = {key: (", ".join(map(str, value)) if isinstance(value, (list, tuple)) else value) for key, value in row.items()}
        writer.writerow(clean_row)

    output.seek(0)
    return output


@router.get("/lists/{list_id}/export/csv")
async def export_list_items_csv(
        list_id: int,
        db: Session = Depends(get_db)
):
    """Export items from a specific list to CSV"""
    try:
        # Get the list and verify it exists
        saved_list = db.query(models.SavedList).filter(models.SavedList.id == list_id).first()
        if not saved_list:
            raise HTTPException(status_code=404, detail="List not found")

        # Get list items
        items = crud.saved_list.get_list_items(db=db, list_id=list_id)
        if not items:
            raise HTTPException(status_code=404, detail="No items found in list")

        # Generate CSV based on list type
        if saved_list.list_type.lower() == 'investor':
            headers = [
                "id", "first_name", "last_name", "email", "phone",
                "firm_name", "city", "state", "country",
                "type_of_financing", "industry_preferences",
                "stage_preferences", "capital_managed"
            ]
        else:
            headers = [
                "id", "firm_name", "firm_type", "contact_email",
                "firm_city", "firm_state", "firm_country",
                "financing_type", "industry_preferences",
                "stage_preferences", "capital_managed"
            ]

        # Generate CSV content
        output = io.StringIO()
        writer = csv.DictWriter(output, fieldnames=headers)
        writer.writeheader()

        for item in items:
            # Clean up the row data
            row = {k: (', '.join(map(str, v)) if isinstance(v, (list, tuple)) else v)
                   for k, v in item.items() if k in headers}
            writer.writerow(row)

        output.seek(0)

        # Stream the CSV
        return StreamingResponse(
            iter([output.getvalue()]),
            media_type="text/csv",
            headers={
                'Content-Disposition': f'attachment; filename="{saved_list.name}_{datetime.now().strftime("%Y%m%d")}.csv"'
            }
        )

    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Error exporting list items: {str(e)}")
        raise HTTPException(status_code=500, detail="Error generating export")

================
File: api/v1/endpoints/investment_funds.py
================
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import or_, and_, cast, ARRAY, String, func, text
from sqlalchemy.sql import expression
from sqlalchemy.orm import Session
from typing import List, Dict
import models
import schemas
from database import get_db
import crud
import logging

router = APIRouter()
logger = logging.getLogger(__name__)


@router.post("/", response_model=None)
def create_fund(fund: schemas.InvestmentFundCreate, db: Session = Depends(get_db)):
    try:
        return crud.investment_fund.create(db=db, obj_in=fund)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.get("/", response_model=None)
def read_funds(
        db: Session = Depends(get_db),
        page: int = Query(1, gt=0, description="Page number"),
        per_page: int = Query(50, gt=0, le=100, description="Items per page")
):
    try:
        # Get total count
        total = db.query(models.InvestmentFund).count()

        # Calculate skip
        skip = (page - 1) * per_page

        # Get paginated results
        funds = crud.investment_fund.get_multi(
            db=db,
            skip=skip,
            limit=per_page
        )

        return {
            "total": total,
            "page": page,
            "per_page": per_page,
            "total_pages": -(-total // per_page),
            "data": funds
        }
    except Exception as e:
        logger.error(f"Error fetching funds: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{fund_id}", response_model=None)
def read_fund(fund_id: int, db: Session = Depends(get_db)):
    try:
        db_fund = crud.investment_fund.get(db, id=fund_id)
        if db_fund is None:
            raise HTTPException(status_code=404, detail="Investment Fund not found")
        return db_fund
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/{fund_id}", response_model=None)
def update_fund(fund_id: int, fund: schemas.InvestmentFundCreate, db: Session = Depends(get_db)):
    try:
        db_fund = crud.investment_fund.update(db, id=fund_id, obj_in=fund)
        if db_fund is None:
            raise HTTPException(status_code=404, detail="Investment Fund not found")
        return db_fund
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.delete("/{fund_id}", response_model=None)
def delete_fund(fund_id: int, db: Session = Depends(get_db)):
    try:
        db_fund = crud.investment_fund.delete(db, id=fund_id)
        if db_fund is None:
            raise HTTPException(status_code=404, detail="Investment Fund not found")
        return db_fund
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.post("/search")
async def search_funds(
        filters: schemas.InvestmentFundFilterParams,
        db: Session = Depends(get_db),
        page: int = Query(1, gt=0),
        per_page: int = Query(50, gt=1, le=100)
):
    try:
        query = db.query(models.InvestmentFund)

        # Basic text search
        if filters.searchTerm:
            search = f"%{filters.searchTerm}%"
            query = query.filter(or_(
                models.InvestmentFund.firm_name.ilike(search),
                models.InvestmentFund.full_name.ilike(search),
                models.InvestmentFund.firm_email.ilike(search),
                models.InvestmentFund.contact_email.ilike(search),
                models.InvestmentFund.description.ilike(search)
            ))

        # Location filters
        if filters.location:
            if filters.location.city:
                query = query.filter(or_(*[
                    models.InvestmentFund.firm_city.ilike(f"%{city}%")
                    for city in filters.location.city
                ]))
            if filters.location.state:
                query = query.filter(or_(*[
                    models.InvestmentFund.firm_state.ilike(f"%{state}%")
                    for state in filters.location.state
                ]))
            if filters.location.country:
                query = query.filter(or_(*[
                    models.InvestmentFund.firm_country.ilike(f"%{country}%")
                    for country in filters.location.country
                ]))
            if filters.location.location_preferences and len(filters.location.location_preferences) > 0:
                query = query.filter(
                    models.InvestmentFund.geographic_preferences.op('&&')(
                        cast(filters.location.location_preferences, ARRAY(String))
                    )
                )

        # Contact info filters
        if filters.contactInfo:
            if filters.contactInfo.hasEmail:
                query = query.filter(or_(
                    models.InvestmentFund.firm_email.isnot(None),
                    models.InvestmentFund.contact_email.isnot(None)
                ))
            if filters.contactInfo.hasPhone:
                query = query.filter(or_(
                    models.InvestmentFund.firm_phone.isnot(None),
                    models.InvestmentFund.contact_phone.isnot(None)
                ))
            if filters.contactInfo.hasAddress:
                query = query.filter(and_(
                    models.InvestmentFund.firm_address.isnot(None),
                    models.InvestmentFund.firm_city.isnot(None)
                ))

        # Industry filters
        if filters.industry and filters.industry.industries:
            query = query.filter(
                models.InvestmentFund.industry_preferences.op('&&')(
                    cast(filters.industry.industries, ARRAY(String))
                )
            )
        # Fund type filter
        if filters.fundType and filters.fundType.types:
            query = query.filter(or_(*[
                or_(
                    models.InvestmentFund.firm_type.ilike(f"%{t}%"),
                    models.InvestmentFund.financing_type.ilike(f"%{t}%")
                ) for t in filters.fundType.types
            ]))

        # Investment stages
        if filters.stages and filters.stages.stages:
            query = query.filter(
                models.InvestmentFund.stage_preferences.op('&&')(
                    cast(filters.stages.stages, ARRAY(String))
                )
            )

        # Investment ranges
        if filters.investmentRanges:
            from api.v1.dependencies import parse_investment_range

            if filters.investmentRanges.assetsUnderManagement:
                min_val, max_val = parse_investment_range(filters.investmentRanges.assetsUnderManagement)
                if min_val is not None:
                    query = query.filter(models.InvestmentFund.capital_managed >= min_val)
                if max_val is not None:
                    query = query.filter(models.InvestmentFund.capital_managed <= max_val)

            if filters.investmentRanges.minInvestment:
                min_val, max_val = parse_investment_range(filters.investmentRanges.minInvestment)
                if min_val is not None:
                    query = query.filter(models.InvestmentFund.min_investment >= min_val)
                if max_val is not None:
                    query = query.filter(models.InvestmentFund.min_investment <= max_val)

        # Calculate pagination
        total = query.count()
        skip = (page - 1) * per_page
        results = query.offset(skip).limit(per_page).all()

        return {
            "total": total,
            "page": page,
            "per_page": per_page,
            "total_pages": -(-total // per_page),
            "results": [crud.investment_fund.to_dict(r) for r in results]
        }

    except Exception as e:
        logger.error(f"Error searching investment funds: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


def apply_fund_filters(query, filters):
    """Apply filters to investment fund query"""
    if not filters:
        return query

    if filters.searchTerm:
        search = f"%{filters.searchTerm}%"
        query = query.filter(models.InvestmentFund.firm_name.ilike(search) |
                             models.InvestmentFund.full_name.ilike(search) |
                             models.InvestmentFund.firm_email.ilike(search) |
                             models.InvestmentFund.contact_email.ilike(search) |
                             models.InvestmentFund.description.ilike(search))

    if filters.location:
        if filters.location.city:
            query = query.filter(models.InvestmentFund.firm_city.in_(filters.location.city))
        if filters.location.state:
            query = query.filter(models.InvestmentFund.firm_state.in_(filters.location.state))
        if filters.location.country:
            query = query.filter(models.InvestmentFund.firm_country.in_(filters.location.country))
        if filters.location.location_preferences:
            query = query.filter(models.InvestmentFund.geographic_preferences.overlap(
                filters.location.location_preferences
            ))

    if filters.industry and filters.industry.industries:
        query = query.filter(models.InvestmentFund.industry_preferences.overlap(
            filters.industry.industries
        ))

    if filters.stages and filters.stages.stages:
        query = query.filter(models.InvestmentFund.stage_preferences.overlap(
            filters.stages.stages
        ))

    if filters.fundType and filters.fundType.types:
        query = query.filter(models.InvestmentFund.firm_type.in_(filters.fundType.types))

    return query

================
File: api/v1/endpoints/investors.py
================
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import or_, cast, ARRAY, String
from sqlalchemy.orm import Session
import models
import schemas
from database import get_db
import crud
import logging

router = APIRouter()
logger = logging.getLogger(__name__)


@router.post("/", response_model=None)
def create_investor(investor: schemas.InvestorCreate, db: Session = Depends(get_db)):
    try:
        return crud.investor.create(db=db, obj_in=investor)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.get("/", response_model=None)
def read_investors(
        db: Session = Depends(get_db),
        page: int = Query(1, gt=0, description="Page number"),
        per_page: int = Query(50, gt=0, le=100, description="Number of items per page"),
):
    try:
        # Get Total Count
        total = db.query(models.Investor).count()

        # Calculate Offset
        skip = (page - 1) * per_page

        # Get paginated results
        investors = crud.investor.get_multi(
            db=db,
            skip=skip,
            limit=per_page,
        )

        return {
            "total": total,
            "page": page,
            "per_page": per_page,
            "total_pages": -(-total // per_page),
            "data": investors,
        }
    except Exception as e:
        logger.error(f"Error fetching investors: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{investor_id}", response_model=None)  # Remove response model
def read_investor(investor_id: int, db: Session = Depends(get_db)):
    try:
        db_investor = crud.investor.get(db, id=investor_id)
        if db_investor is None:
            raise HTTPException(status_code=404, detail="Investor not found")
        return db_investor
    except ValueError as e:
        raise HTTPException(status_code=422, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/{investor_id}", response_model=None)
def update_investor(investor_id: int, investor: schemas.InvestorCreate, db: Session = Depends(get_db)):
    try:
        db_investor = crud.investor.update(db, id=investor_id, obj_in=investor)
        if db_investor is None:
            raise HTTPException(status_code=404, detail="Investor not found")
        return db_investor
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.delete("/{investor_id}", response_model=None)
def delete_investor(investor_id: int, db: Session = Depends(get_db)):
    try:
        db_investor = crud.investor.delete(db, id=investor_id)
        if db_investor is None:
            raise HTTPException(status_code=404, detail="Investor not found")
        return db_investor
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.post("/search")
async def search_investors(
        filters: schemas.InvestorFilterParams,
        db: Session = Depends(get_db),
        page: int = Query(1, gt=0),
        per_page: int = Query(50, gt=1, le=100)
):
    try:
        query = db.query(models.Investor)

        # Basic text search
        if filters.searchTerm:
            search = f"%{filters.searchTerm}%"
            query = query.filter(or_(
                models.Investor.first_name.ilike(search),
                models.Investor.last_name.ilike(search),
                models.Investor.firm_name.ilike(search),
                models.Investor.email.ilike(search),
                models.Investor.contact_title.ilike(search)
            ))

        # Location filters
        if filters.location:
            if filters.location.city:
                query = query.filter(or_(*[
                    models.Investor.city.ilike(f"%{city}%")
                    for city in filters.location.city
                ]))
            if filters.location.state:
                query = query.filter(or_(*[
                    models.Investor.state.ilike(f"%{state}%")
                    for state in filters.location.state
                ]))
            if filters.location.country:
                query = query.filter(or_(*[
                    models.Investor.country.ilike(f"%{country}%")
                    for country in filters.location.country
                ]))
            if filters.location.location_preferences and len(filters.location.location_preferences) > 0:
                query = query.filter(
                    models.Investor.geographic_preferences.op('&&')(
                        cast(filters.location.location_preferences, ARRAY(String))
                    )
                )

        # Contact info filters
        if filters.contactInfo:
            if filters.contactInfo.hasEmail:
                query = query.filter(models.Investor.email.isnot(None))
            if filters.contactInfo.hasPhone:
                query = query.filter(models.Investor.phone.isnot(None))
            if filters.contactInfo.hasAddress:
                query = query.filter(models.Investor.city.isnot(None))

        # Industry preferences
        if filters.industry and filters.industry.industries:
            query = query.filter(
                models.Investor.industry_preferences.op('&&')(
                    cast(filters.industry.industries, ARRAY(String))
                )
            )

        # Fund type filter
        if filters.fundType and filters.fundType.types:
            query = query.filter(
                models.Investor.type_of_financing.in_(filters.fundType.types)
            )

        # Investment stages
        if filters.stages and filters.stages.stages:
            query = query.filter(
                models.Investor.stage_preferences.op('&&')(
                    cast(filters.stages.stages, ARRAY(String))
                )
            )

        # Investment ranges
        if filters.investmentRanges:
            from api.v1.dependencies import parse_investment_range

            if filters.investmentRanges.assetsUnderManagement:
                min_val, max_val = parse_investment_range(filters.investmentRanges.assetsUnderManagement)
                if min_val is not None:
                    query = query.filter(models.Investor.capital_managed >= min_val)
                if max_val is not None:
                    query = query.filter(models.Investor.capital_managed <= max_val)

            if filters.investmentRanges.minInvestment:
                min_val, max_val = parse_investment_range(filters.investmentRanges.minInvestment)
                if min_val is not None:
                    query = query.filter(models.Investor.min_investment >= min_val)
                if max_val is not None:
                    query = query.filter(models.Investor.min_investment <= max_val)

        # Calculate pagination
        total = query.count()
        skip = (page - 1) * per_page
        results = query.offset(skip).limit(per_page).all()

        return {
            "total": total,
            "page": page,
            "per_page": per_page,
            "total_pages": -(-total // per_page),
            "results": [crud.investor.to_dict(r) for r in results]
        }

    except Exception as e:
        logger.error(f"Error searching investors: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


def apply_investor_filters(query, filters):
    """Apply filters to investor query"""
    if not filters:
        return query

    if filters.searchTerm:
        search = f"%{filters.searchTerm}%"
        query = query.filter(models.Investor.first_name.ilike(search) |
                             models.Investor.last_name.ilike(search) |
                             models.Investor.firm_name.ilike(search) |
                             models.Investor.email.ilike(search) |
                             models.Investor.contact_title.ilike(search))

    if filters.location:
        if filters.location.city:
            query = query.filter(models.Investor.city.in_(filters.location.city))
        if filters.location.state:
            query = query.filter(models.Investor.state.in_(filters.location.state))
        if filters.location.country:
            query = query.filter(models.Investor.country.in_(filters.location.country))
        if filters.location.location_preferences:
            query = query.filter(models.Investor.geographic_preferences.overlap(
                filters.location.location_preferences
            ))

    if filters.industry and filters.industry.industries:
        query = query.filter(models.Investor.industry_preferences.overlap(
            filters.industry.industries
        ))

    if filters.stages and filters.stages.stages:
        query = query.filter(models.Investor.stage_preferences.overlap(
            filters.stages.stages
        ))

    if filters.fundType and filters.fundType.types:
        query = query.filter(models.Investor.type_of_financing.in_(filters.fundType.types))

    if filters.gender and filters.gender.gender:
        query = query.filter(models.Investor.gender == filters.gender.gender)

    return query

================
File: api/v1/endpoints/lists.py
================
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import StreamingResponse
from sqlalchemy.orm import Session, joinedload
from typing import List
import models
import schemas
from database import get_db
import crud
import logging
from datetime import datetime
import io
import csv

router = APIRouter()
logger = logging.getLogger(__name__)


@router.post("/", response_model=schemas.SavedList)
def create_list(
        list_data: schemas.SavedListCreate,
        db: Session = Depends(get_db)
):
    """Create a new saved list"""
    return crud.saved_list.create(db=db, obj_in=list_data)


@router.get("/", response_model=List[schemas.SavedList])
def get_all_lists(
        db: Session = Depends(get_db),
        skip: int = 0,
        limit: int = 100
):
    """Get all saved lists"""
    return crud.saved_list.get_multi(db=db, skip=skip, limit=limit)


@router.post("/{list_id}/investors/{investor_id}")
def add_investor_to_list(
        list_id: int,
        investor_id: int,
        db: Session = Depends(get_db)
):
    """Add an investor to a saved list"""
    success = crud.saved_list.add_investor_to_list(db=db, list_id=list_id, investor_id=investor_id)
    if not success:
        raise HTTPException(status_code=404, detail="List or investor not found")
    return {"status": "success"}


@router.post("/{list_id}/funds/{fund_id}")
def add_fund_to_list(
        list_id: int,
        fund_id: int,
        db: Session = Depends(get_db)
):
    """Add a fund to a saved list"""
    success = crud.saved_list.add_fund_to_list(db=db, list_id=list_id, fund_id=fund_id)
    if not success:
        raise HTTPException(status_code=404, detail="List or fund not found")
    return {"status": "success"}


@router.delete("/{list_id}/investors/{investor_id}")
def remove_investor_from_list(
        list_id: int,
        investor_id: int,
        db: Session = Depends(get_db)
):
    """Remove an investor from a saved list"""
    success = crud.saved_list.remove_investor_from_list(db=db, list_id=list_id, investor_id=investor_id)
    if not success:
        raise HTTPException(status_code=404, detail="List or investor not found")
    return {"status": "success"}


@router.delete("/{list_id}/funds/{fund_id}")
def remove_fund_from_list(
        list_id: int,
        fund_id: int,
        db: Session = Depends(get_db)
):
    """Remove a fund from a saved list"""
    success = crud.saved_list.remove_fund_from_list(db=db, list_id=list_id, fund_id=fund_id)
    if not success:
        raise HTTPException(status_code=404, detail="List or fund not found")
    return {"status": "success"}


@router.get("/{list_id}/items", response_model=None)
async def get_list_items_combined(
        list_id: int,
        db: Session = Depends(get_db)
):
    """Get all items in a saved list, including both investors and funds"""
    try:
        logger.info(f"Retrieving items for list {list_id}")

        # Get the list with all relationships loaded
        saved_list = db.query(models.SavedList) \
            .options(joinedload(models.SavedList.saved_investors)) \
            .options(joinedload(models.SavedList.saved_funds)) \
            .filter(models.SavedList.id == list_id) \
            .first()

        if not saved_list:
            logger.error(f"List with id {list_id} not found")
            raise HTTPException(status_code=404, detail="List not found")

        # Get investors if any exist
        investors = []
        if saved_list.saved_investors:
            investor_ids = [inv.id for inv in saved_list.saved_investors]
            db_investors = db.query(models.Investor) \
                .filter(models.Investor.id.in_(investor_ids)) \
                .all()
            investors = [crud.investor.to_dict(inv) for inv in db_investors]
            logger.info(f"Found {len(investors)} investors")

        # Get funds if any exist
        funds = []
        if saved_list.saved_funds:
            fund_ids = [fund.id for fund in saved_list.saved_funds]
            db_funds = db.query(models.InvestmentFund) \
                .filter(models.InvestmentFund.id.in_(fund_ids)) \
                .all()
            funds = [crud.investment_fund.to_dict(fund) for fund in db_funds]
            logger.info(f"Found {len(funds)} funds")

        # Combine both types of items into a single response
        response = {
            "list_id": list_id,
            "list_name": saved_list.name,
            "list_type": saved_list.list_type,
            "total_items": len(investors) + len(funds),
            "items": {
                "investors": {
                    "count": len(investors),
                    "data": investors
                },
                "funds": {
                    "count": len(funds),
                    "data": funds
                }
            }
        }

        logger.info(f"Successfully retrieved {response['total_items']} items from list")
        return response

    except Exception as e:
        logger.error(f"Error retrieving list items: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{list_id}/items/by-type", response_model=None)
async def get_list_items_by_type(
        list_id: int,
        db: Session = Depends(get_db)
):
    """Get all items in a saved list based on list type"""
    try:
        logger.info(f"Attempting to retrieve items for list {list_id}")

        # Get the list with relationships loaded
        saved_list = db.query(models.SavedList) \
            .options(joinedload(models.SavedList.saved_investors)) \
            .options(joinedload(models.SavedList.saved_funds)) \
            .filter(models.SavedList.id == list_id) \
            .first()

        if not saved_list:
            logger.error(f"List with id {list_id} not found")
            raise HTTPException(status_code=404, detail="List not found")

        logger.info(f"Found list: {saved_list.name} (type: {saved_list.list_type})")

        # Convert items to dictionaries based on list type
        if saved_list.list_type.lower() == 'investor':
            # Get the actual investor records
            investor_ids = [inv.id for inv in saved_list.saved_investors]
            investors = db.query(models.Investor) \
                .filter(models.Investor.id.in_(investor_ids)) \
                .all()

            items = [crud.investor.to_dict(inv) for inv in investors]
            logger.info(f"Retrieved {len(items)} investors")
        else:
            # Get the actual fund records
            fund_ids = [fund.id for fund in saved_list.saved_funds]
            funds = db.query(models.InvestmentFund) \
                .filter(models.InvestmentFund.id.in_(fund_ids)) \
                .all()

            items = [crud.investment_fund.to_dict(fund) for fund in funds]
            logger.info(f"Retrieved {len(items)} funds")

        # Return formatted response
        return {
            "list_id": list_id,
            "list_name": saved_list.name,
            "list_type": saved_list.list_type,
            "total_items": len(items),
            "items": items
        }

    except Exception as e:
        logger.error(f"Error retrieving list items: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Internal server error: {str(e)}"
        )


@router.put("/{list_id}/type", response_model=None)
async def update_list_type(
        list_id: int,
        list_type: str,
        db: Session = Depends(get_db)
):
    """Update the type of a saved list"""
    try:
        saved_list = db.query(models.SavedList).filter(models.SavedList.id == list_id).first()
        if not saved_list:
            raise HTTPException(status_code=404, detail="List not found")

        # Update list type
        saved_list.list_type = list_type
        db.commit()

        return {
            "message": "List type updated successfully",
            "list_id": list_id,
            "new_type": list_type
        }
    except Exception as e:
        logger.error(f"Error updating list type: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/export/{list_id}")
async def export_list(
        list_id: int,
        db: Session = Depends(get_db)
):
    """Export all items from a specific list"""
    try:
        # Get the list and its items
        items_response = await get_list_items_combined(list_id, db)

        # Process investors
        investor_data = items_response["items"]["investors"]["data"]
        investor_fields = [
            "id", "first_name", "last_name", "email", "phone",
            "firm_name", "city", "state", "country",
            "type_of_financing", "industry_preferences",
            "stage_preferences", "capital_managed"
        ]

        # Process funds
        fund_data = items_response["items"]["funds"]["data"]
        fund_fields = [
            "id", "firm_name", "firm_type", "contact_email",
            "firm_city", "firm_state", "firm_country",
            "financing_type", "industry_preferences",
            "stage_preferences", "capital_managed"
        ]

        # Generate CSV
        output = io.StringIO()

        # Write investors section
        writer = csv.DictWriter(output, fieldnames=investor_fields)
        writer.writeheader()
        for investor in investor_data:
            row = {k: (', '.join(map(str, v)) if isinstance(v, (list, tuple)) else v)
                   for k, v in investor.items() if k in investor_fields}
            writer.writerow(row)

        # Add separator
        output.write("\n--- Investment Funds ---\n\n")

        # Write funds section
        writer = csv.DictWriter(output, fieldnames=fund_fields)
        writer.writeheader()
        for fund in fund_data:
            row = {k: (', '.join(map(str, v)) if isinstance(v, (list, tuple)) else v)
                   for k, v in fund.items() if k in fund_fields}
            writer.writerow(row)

        output.seek(0)

        return StreamingResponse(
            iter([output.getvalue()]),
            media_type="text/csv",
            headers={
                "Content-Disposition": f"attachment; filename=list_{list_id}_export_{datetime.now().strftime('%Y%m%d')}.csv"
            }
        )

    except Exception as e:
        logger.error(f"Error exporting list: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

================
File: api/v1/endpoints/utils.py
================
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Dict
import models
from database import get_db
import logging

router = APIRouter()
logger = logging.getLogger(__name__)


@router.get("/stats")
def get_database_stats(db: Session = Depends(get_db)) -> Dict:
    """Get database statistics"""
    try:
        total_investors = db.query(models.Investor).count()
        total_funds = db.query(models.InvestmentFund).count()
        return {
            "total_investors": total_investors,
            "total_investment_funds": total_funds
        }
    except Exception as e:
        logger.error(f"Error getting stats: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/test-pagination")
def test_pagination(
        db: Session = Depends(get_db),
        page: int = Query(1, gt=0),
        per_page: int = Query(100, gt=0, le=500)
):
    """Test Pagination with metrics"""
    try:
        skip = (page - 1) * per_page

        # Get Investors
        total_investors = db.query(models.Investor).count()
        investors = db.query(models.Investor).offset(skip).limit(per_page).all()

        # Get Investment Funds
        total_funds = db.query(models.InvestmentFund).count()
        funds = db.query(models.InvestmentFund).offset(skip).limit(per_page).all()

        return {
            "pagination": {
                "page": page,
                "per_page": per_page,
                "total_investors": total_investors,
                "total_funds": total_funds,
                "total_pages_investors": -(-total_investors // per_page),
                "total_pages_funds": -(-total_funds // per_page),
            },
            "current_page_data": {
                "investor_count": len(investors),
                "funds_count": len(funds),
                "skip": skip,
                "investors_sample": [{"id": inv.id, "email": inv.email} for inv in investors[:5]],
                "funds_sample": [{"id": fund.id, "name": fund.firm_name} for fund in funds[:5]]
            }
        }
    except Exception as e:
        logger.error(f"Error in test-pagination: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

================
File: api/v1/dependencies.py
================
from typing import Optional, Tuple


def parse_investment_range(range_str: str) -> Tuple[Optional[float], Optional[float]]:
    """Convert string investment range to numeric min/max values"""
    if not range_str:
        return None, None

    ranges = {
        # Assets Under Management
        "1B_PLUS": (1_000_000_000, None),
        "100M_500M": (100_000_000, 500_000_000),
        "500M_1B": (500_000_000, 1_000_000_000),
        "25M_100M": (25_000_000, 100_000_000),
        "0_25M": (0, 25_000_000),

        # Min Investment
        "25K_250K": (25_000, 250_000),
        "250K_1M": (250_000, 1_000_000),
        "1M_5M": (1_000_000, 5_000_000),
        "5M_PLUS": (5_000_000, None),

        # Max Investment
        "25M_150M": (25_000_000, 150_000_000),
        "10M_25M": (10_000_000, 25_000_000),
        "1M_10M": (1_000_000, 10_000_000),
        "150M_PLUS": (150_000_000, None)
    }

    return ranges.get(range_str, (None, None))

================
File: middleware/rate_limit.py
================
from fastapi import HTTPException, Request
from datetime import datetime, timedelta, UTC
import logging
from typing import Dict, Optional
from fastapi import FastAPI
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse

logger = logging.getLogger(__name__)


class RateLimitMiddleware(BaseHTTPMiddleware):
    def __init__(
            self,
            app: FastAPI,
            rate_limit_duration: int = 24 * 60 * 60,  # 24 hours in seconds
            default_limit: int = 1000  # Default requests per duration
    ):
        super().__init__(app)
        self.requests: Dict[str, list] = {}
        self.rate_limit_duration = rate_limit_duration
        self.default_limit = default_limit

        # Define tier limits - you can modify these based on your needs
        self.tier_limits = {
            "basic": 1000,  # 1000 requests per day
            "professional": 5000,  # 5000 requests per day
            "enterprise": 10000  # 10000 requests per day
        }

    async def dispatch(self, request: Request, call_next):
        # Get client identifier (you might want to use API key or token instead)
        client_id = self._get_client_identifier(request)

        # Get user's tier (you'll need to implement this based on your auth system)
        user_tier = await self._get_user_tier(request)

        try:
            # Check rate limit
            await self._check_rate_limit(client_id, user_tier)

            # Process the request
            response = await call_next(request)
            return response

        except HTTPException as exc:
            return JSONResponse(
                status_code=exc.status_code,
                content={"detail": exc.detail}
            )

    def _get_client_identifier(self, request: Request) -> str:
        # You might want to use API key or token instead of IP
        return request.client.host if request.client else "unknown"

    async def _get_user_tier(self, request: Request) -> str:
        # Implement your logic to get user tier from auth token/header
        # This is a placeholder - modify based on your auth system
        return "basic"

    async def _check_rate_limit(self, client_id: str, tier: str):
        now = datetime.now(UTC)

        # Initialize client's request history if not exists
        if client_id not in self.requests:
            self.requests[client_id] = []

        # Remove old requests
        cutoff_time = now - timedelta(seconds=self.rate_limit_duration)
        self.requests[client_id] = [
            req_time for req_time in self.requests[client_id]
            if req_time > cutoff_time
        ]

        # Get limit based on tier
        limit = self.tier_limits.get(tier, self.default_limit)

        # Check if limit exceeded
        if len(self.requests[client_id]) >= limit:
            logger.warning(f"Rate limit exceeded for client {client_id} (tier: {tier})")
            raise HTTPException(
                status_code=429,
                detail=f"Rate limit of {limit} requests per {self.rate_limit_duration // 3600} hours exceeded"
            )

        # Add current request
        self.requests[client_id].append(now)


# Usage example for clearing old rate limit data
def cleanup_rate_limits(rate_limiter: RateLimitMiddleware):
    """Cleanup old rate limit data periodically"""
    now = datetime.now(UTC)
    cutoff_time = now - timedelta(seconds=rate_limiter.rate_limit_duration)

    for client_id in list(rate_limiter.requests.keys()):
        rate_limiter.requests[client_id] = [
            req_time for req_time in rate_limiter.requests[client_id]
            if req_time > cutoff_time
        ]
        # Remove empty client records
        if not rate_limiter.requests[client_id]:
            del rate_limiter.requests[client_id]

================
File: scripts/import_data.py
================
import pandas as pd
from sqlalchemy.orm import Session
from sqlalchemy.dialects.postgresql import insert
from database import engine
from models import Base, Investor, InvestmentFund
from typing import Type, Union
import logging
import os
import traceback

# Get the absolute path of the project root directory
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

Base.metadata.create_all(bind=engine)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def get_column_mappings(model):
    if model == InvestmentFund:
        return {
            'Full Name': 'full_name',
            'Title': 'title',
            'Contact Email': 'contact_email',
            'Contact Phone': 'contact_phone',
            'Firm Name': 'firm_name',
            'Firm Email': 'firm_email',
            'Firm Phone': 'firm_phone',
            'Firm Website': 'firm_website',
            'Firm Address': 'firm_address',
            'Firm City': 'firm_city',
            'Firm State': 'firm_state',
            'Firm Zip': 'firm_zip',
            'Firm Country': 'firm_country',
            'Office Type': 'office_type',
            'Financing Type': 'financing_type',
            'Industry Preferences': 'industry_preferences',
            'Geographic Preferences': 'geographic_preferences',
            'Stage Preferences': 'stage_preferences',
            'Capital Managed': 'capital_managed',
            'Min. Investment': 'min_investment',
            'Max. Investment': 'max_investment',
            'Firm Type': 'firm_type'
        }
    else:  # Investor
        return {
            'Prefix': 'prefix',
            'First Name': 'first_name',
            'Last Name': 'last_name',
            'Gender': 'gender',
            'Contact Title': 'contact_title',
            'Email': 'email',
            'Phone': 'phone',
            'Office Website': 'office_website',
            'Firm Name': 'firm_name',
            'City': 'city',
            'Country': 'country',
            'Type of Financing': 'type_of_financing',
            'Industry Preferences': 'industry_preferences',
            'Geographic Preferences': 'geographic_preferences',
            'Stage Preferences': 'stage_preferences',
            'Capital Managed': 'capital_managed',
            'Min Investment': 'min_investment',
            'Max Investment': 'max_investment'
        }


def clean_and_convert_data(df: pd.DataFrame, model: Type[Union[Investor, InvestmentFund]]) -> pd.DataFrame:
    logger.info("\nStarting data cleaning and conversion")

    def convert_currency(value):
        if pd.isna(value) or value is None or value == '':
            return None
        try:
            # If value is already a number, return it
            if isinstance(value, (int, float)):
                return float(value) if value != 0 else None

            # If it's a string, clean and convert
            if isinstance(value, str):
                # Handle lists stored as strings
                if value.startswith('[') and value.endswith(']'):
                    return None
                # Remove any non-numeric characters except dots
                value_str = ''.join(c for c in value if c.isdigit() or c == '.')
                if value_str:
                    result = float(value_str)
                    return result if result != 0 else None
            return None
        except Exception as e:
            logger.error(f"Error converting value '{value}' ({type(value)}): {str(e)}")
            return None

    def convert_list_field(value):
        if pd.isna(value) or value is None or value == '':
            return None
        try:
            if isinstance(value, str):
                # If it's already in list format, try to evaluate it
                if value.startswith('[') and value.endswith(']'):
                    try:
                        # Clean the string before eval
                        cleaned_value = value.replace('", "', '","').strip()
                        result = eval(cleaned_value)
                        return result if result else None
                    except:
                        # If eval fails, split by comma
                        value = value.strip('[]')
                        if value:
                            return [item.strip().strip('"\'') for item in value.split(',') if item.strip()]
                        return None
                # Otherwise split by comma
                return [item.strip() for item in value.split(',') if item.strip()]
            elif isinstance(value, list):
                return value
            return None
        except Exception as e:
            logger.error(f"Error converting list value '{value}' ({type(value)}): {str(e)}")
            return None

    # Replace 'Unknown' and empty strings with None
    df = df.replace({'Unknown': None, '': None, 'N/A': None})

    # Convert numeric fields
    numeric_cols = ['min_investment', 'max_investment', 'capital_managed']

    # Process each numeric column
    for col in numeric_cols:
        if col in df.columns:
            logger.info(f"\nProcessing column: {col}")
            logger.info(f"Original values (first 5):\n{df[col].head()}")

            # Convert to numeric
            df[col] = df[col].apply(convert_currency)

            logger.info(f"Converted values (first 5):\n{df[col].head()}")
            non_null_count = df[col].notnull().sum()
            logger.info(f"Number of non-null values: {non_null_count}")

    # Handle list fields
    list_fields = ['industry_preferences', 'geographic_preferences', 'stage_preferences']
    if model == Investor:
        list_fields.append('type_of_financing')

    for field in list_fields:
        if field in df.columns:
            logger.info(f"\nProcessing list field: {field}")
            logger.info(f"Original values (first 5):\n{df[field].head()}")

            df[field] = df[field].apply(convert_list_field)

            logger.info(f"Converted values (first 5):\n{df[field].head()}")
            non_null_count = df[field].notnull().sum()
            logger.info(f"Number of non-null values: {non_null_count}")

    return df


def import_investors(csv_file: str, session: Session):
    logger.info("\nProcessing Investors data...")
    df = pd.read_csv(csv_file)

    # Print column info
    logger.info(f"Columns in CSV: {df.columns.tolist()}")
    logger.info("\nSample of numeric columns before processing:")
    for col in ['Min Investment', 'Max Investment', 'Capital Managed']:
        if col in df.columns:
            logger.info(f"\n{col}:")
            logger.info(df[col].head())

    # Rename columns
    df = df.rename(columns=get_column_mappings(Investor))

    df_cleaned = clean_and_convert_data(df, Investor)

    # Process in chunks
    chunk_size = 1000
    records_processed = 0

    for start_idx in range(0, len(df_cleaned), chunk_size):
        chunk = df_cleaned.iloc[start_idx:start_idx + chunk_size]

        for _, row in chunk.iterrows():
            try:
                # Convert row to dict and remove None values
                record = {k: v for k, v in row.items() if v is not None and k in Investor.__table__.columns.keys()}

                # Create an UPSERT statement
                stmt = insert(Investor).values(**record)
                stmt = stmt.on_conflict_do_update(
                    index_elements=['email'],
                    set_=record
                )
                session.execute(stmt)
                session.commit()
                records_processed += 1

            except Exception as e:
                logger.error(f"Error inserting investor record: {str(e)}")
                logger.error(f"Problematic record: {record}")
                session.rollback()

            if records_processed % 100 == 0:
                logger.info(f"Processed {records_processed} investor records")

        logger.info(f"Processed {records_processed} investor records in current chunk")

    logger.info(f"Total investors processed: {records_processed}")
    return records_processed


def import_investment_funds(csv_file: str, session: Session):
    logger.info("\nProcessing Investment Funds data...")
    df = pd.read_csv(csv_file)

    # Rename columns
    df = df.rename(columns=get_column_mappings(InvestmentFund))

    df_cleaned = clean_and_convert_data(df, InvestmentFund)

    # Process in chunks
    chunk_size = 1000
    records_processed = 0

    for start_idx in range(0, len(df_cleaned), chunk_size):
        chunk = df_cleaned.iloc[start_idx:start_idx + chunk_size]

        for _, row in chunk.iterrows():
            try:
                # Convert row to dict and remove None values
                record = {k: v for k, v in row.items() if
                          v is not None and k in InvestmentFund.__table__.columns.keys()}

                # Create an UPSERT statement
                stmt = insert(InvestmentFund).values(**record)
                stmt = stmt.on_conflict_do_update(
                    index_elements=['firm_email'],
                    set_=record
                )
                session.execute(stmt)
                session.commit()
                records_processed += 1

            except Exception as e:
                logger.error(f"Error inserting fund record: {str(e)}")
                logger.error(f"Problematic record: {record}")
                session.rollback()

        logger.info(f"Processed {records_processed} investment fund records")

    return records_processed


def main():
    try:
        with Session(engine) as session:
            # Import Investors
            investors_csv = os.path.join(BASE_DIR, 'data', 'investors_cleaned.csv')
            if os.path.exists(investors_csv):
                total_investors = import_investors(investors_csv, session)

                # Verify investors import
                total_count = session.query(Investor).count()
                logger.info(f"\nTotal investors in database: {total_count}")

                for col in ['min_investment', 'max_investment', 'capital_managed']:
                    count = session.query(Investor).filter(getattr(Investor, col).isnot(None)).count()
                    logger.info(f"Count of non-null values in {col}: {count}")

                    # Show sample values
                    samples = session.query(Investor).filter(getattr(Investor, col).isnot(None)).limit(3).all()
                    if samples:
                        logger.info(f"Sample values for {col}:")
                        for sample in samples:
                            logger.info(f"{getattr(sample, col)}")
            else:
                logger.warning(f"Investors CSV file not found: {investors_csv}")

            # Import Investment Funds
            funds_csv = os.path.join(BASE_DIR, 'data', 'vc_funds.csv')
            if os.path.exists(funds_csv):
                total_funds = import_investment_funds(funds_csv, session)

                # Verify investment funds import
                total_count = session.query(InvestmentFund).count()
                logger.info(f"\nTotal investment funds in database: {total_count}")

                for col in ['min_investment', 'max_investment', 'capital_managed']:
                    count = session.query(InvestmentFund).filter(getattr(InvestmentFund, col).isnot(None)).count()
                    logger.info(f"Count of non-null values in {col}: {count}")

                    # Show sample values
                    samples = session.query(InvestmentFund).filter(getattr(InvestmentFund, col).isnot(None)).limit(
                        3).all()
                    if samples:
                        logger.info(f"Sample values for {col}:")
                        for sample in samples:
                            logger.info(f"{getattr(sample, col)}")
            else:
                logger.warning(f"Investment Funds CSV file not found: {funds_csv}")

    except Exception as e:
        logger.error(f"An error occurred: {str(e)}")
        traceback.print_exc()


if __name__ == "__main__":
    main()

================
File: scripts/reset_database.py
================
from sqlalchemy import create_engine, inspect
from database import SQLALCHEMY_DATABASE_URL
from models import Base


def reset_database():
    engine = create_engine(SQLALCHEMY_DATABASE_URL)
    inspector = inspect(engine)

    # Get list of all table names
    table_names = inspector.get_table_names()

    # Drop all tables
    Base.metadata.drop_all(bind=engine)
    print(f"Dropped tables: {', '.join(table_names)}")

    # Recreate all tables
    Base.metadata.create_all(bind=engine)
    print("Recreated all tables.")


if __name__ == "__main__":
    reset_database()

================
File: scripts/update_schema.py
================
from sqlalchemy import create_engine
from database import SQLALCHEMY_DATABASE_URL
from models import Base


def update_schema():
    engine = create_engine(SQLALCHEMY_DATABASE_URL)

    # This will create tables that don't exist, but won't modify existing tables
    Base.metadata.create_all(bind=engine)

    print("Database schema updated.")


if __name__ == "__main__":
    update_schema()

================
File: .gitignore
================
# Ignore Python cache files
__pycache__/
*.pyc

# Ignore environment variables
.env

# Ignore virtual environments
.venv/
venv/

# Ignore logs and temporary files
*.log

# Ignore IDE-specific files
.idea/

# Ignore system-specific files
.DS_Store
Thumbs.db

================
File: app.py
================
from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from api.v1.endpoints import (
    investors,
    investment_funds,
    export,
    utils,
    lists,
    counts
)
from database import engine, get_db, test_db_connection
import models
import os
import logging
import sys
from datetime import datetime
from middleware.rate_limit import RateLimitMiddleware


# Configure logging
def setup_logging():
    """Configure logging to output to console only"""

    # Configure logging format
    log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    formatter = logging.Formatter(log_format)

    # Set up console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)

    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)

    # Remove any existing handlers
    root_logger.handlers = []
    root_logger.addHandler(console_handler)

    return root_logger


logger = setup_logging()


# Startup and shutdown events
@asynccontextmanager
async def lifespan(_: FastAPI):
    # Startup
    logger.info("Starting application...")
    if not test_db_connection():
        logger.error("Database connection failed!")
        sys.exit(1)

    models.Base.metadata.create_all(bind=engine)
    logger.info("Database tables verified")

    yield

    # Shutdown
    logger.info("Shutting down application...")


# Create FastAPI app
app = FastAPI(
    title="Investor Database API",
    description="API for managing investors and investment funds database",
    version="1.0.0",
    lifespan=lifespan
)

app.add_middleware(
    RateLimitMiddleware,
    rate_limit_duration=24 * 60 * 60,  # 24 hours in seconds
    default_limit=1000  # Default requests per day
)

# Configure CORS
origins = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000").split(",")
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
async def health_check():
    """API health check endpoint"""
    return {
        "status": "healthy",
        "version": "1.0.0",
        "environment": os.getenv("ENVIRONMENT", "development"),
        "database": "connected" if test_db_connection() else "error"
    }


# Public routes - no auth required
public_routes = [
    (utils.router, "/api/v1", "utils")
]

for router, prefix, tag in public_routes:
    app.include_router(router, prefix=prefix, tags=[tag])

protected_routes = [
    (investors.router, "/api/v1/investors", "investors", "basic"),
    (investment_funds.router, "/api/v1/funds", "funds", "basic"),
    (export.router, "/api/v1/export", "export", "professional"),
    (lists.router, "/api/v1/lists", "lists", "basic"),
    (counts.router, "/api/v1/counts", "counts", "basic")  # Add this line
]

for router, prefix, tag, _ in protected_routes:
    app.include_router(
        router,
        prefix=prefix,
        tags=[tag]
    )

if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "app:app",
        host="0.0.0.0",
        port=8000,
        reload=True if os.getenv("ENVIRONMENT") == "development" else False
    )

================
File: crud.py
================
from sqlalchemy.orm import Session
from sqlalchemy import or_, String, Text
import models
import schemas
from typing import TypeVar, Generic, List, Any, Dict, Optional, Type
import logging
import math
from decimal import Decimal

ModelType = TypeVar("ModelType", bound=models.Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=schemas.BaseModel)

logger = logging.getLogger(__name__)


class CRUDBase(Generic[ModelType, CreateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model

    def get_multi(
            self,
            db: Session,
            skip: int = 0,
            limit: int = 100,
            search: Optional[str] = None,
            filters: Optional[Dict] = None,
            sort_by: Optional[str] = None,
            sort_desc: bool = False
    ) -> List[Dict]:
        try:
            query = db.query(self.model)

            # Apply text search across string fields
            if search:
                search_filters = []
                for column in self.model.__table__.columns:
                    if isinstance(column.type, (String, Text)):
                        search_filters.append(getattr(self.model, column.key).ilike(f"%{search}%"))
                if search_filters:
                    query = query.filter(or_(*search_filters))

            # Apply filters
            if filters:
                for key, value in filters.items():
                    if hasattr(self.model, key):
                        if isinstance(value, dict):
                            col = getattr(self.model, key)
                            for op, val in value.items():
                                if op == "gte":
                                    query = query.filter(col >= val)
                                elif op == "lte":
                                    query = query.filter(col <= val)
                        elif isinstance(value, (list, tuple)):
                            # Handle array overlaps for preferences
                            col = getattr(self.model, key)
                            if hasattr(col, 'overlap'):
                                query = query.filter(col.overlap(value))
                            else:
                                query = query.filter(col.in_(value))
                        else:
                            query = query.filter(getattr(self.model, key) == value)

            # Apply sorting
            if sort_by and hasattr(self.model, sort_by):
                order_col = getattr(self.model, sort_by)
                if sort_desc:
                    order_col = order_col.desc()
                query = query.order_by(order_col)

            records = query.offset(skip).limit(limit).all()
            return [self.to_dict(record) for record in records]

        except Exception as e:
            logger.error(f"Error in get_multi: {str(e)}")
            raise

    @staticmethod
    def sanitize_float(value: Any) -> Optional[float]:
        if value is None:
            return None
        if isinstance(value, (float, Decimal)):
            if math.isnan(float(value)) or math.isinf(float(value)):
                return None
            return float(value)
        return value

    @staticmethod
    def sanitize_list(value: Any) -> Optional[List]:
        if value is None:
            return None
        if isinstance(value, list):
            return [str(item) for item in value if item is not None]
        if isinstance(value, str):
            return [value]
        return None

    def to_dict(self, obj: ModelType) -> Dict:
        result = {}
        for column in obj.__table__.columns:
            value = getattr(obj, column.name)

            # Handle different types of values
            if isinstance(value, (float, Decimal)):
                # Handle non-JSON-compliant float values
                if value is None or math.isnan(float(value)) or math.isinf(float(value)):
                    result[column.name] = None
                else:
                    result[column.name] = float(value)
            elif isinstance(value, list):
                # Handle lists (like arrays from postgres)
                if value and isinstance(value[0], str) and value[0].startswith('{'):
                    # Handle PostgreSQL array format {item1,item2}
                    cleaned = value[0].strip('{}').split(',')
                    result[column.name] = [item.strip('"') for item in cleaned if item]
                else:
                    result[column.name] = value
            else:
                result[column.name] = value

        return result

    def create(self, db: Session, obj_in: CreateSchemaType) -> Dict:
        try:
            obj_in_data = self.prepare_data_for_db(obj_in.model_dump())
            db_obj = self.model(**obj_in_data)
            db.add(db_obj)
            db.commit()
            db.refresh(db_obj)
            return self.to_dict(db_obj)
        except Exception as e:
            db.rollback()
            logger.error(f"Error creating {self.model.__name__}: {str(e)}")
            raise

    def get(self, db: Session, id: Any) -> Optional[ModelType]:
        try:
            obj = db.query(self.model).filter(self.model.id == id).first()
            if obj:
                return self.to_dict(obj)
            return None
        except Exception as e:
            logger.error(f"Error in get: {str(e)}")
            raise

    def update(self, db: Session, id: Any, obj_in: CreateSchemaType) -> Optional[Dict]:
        try:
            db_obj = db.query(self.model).filter(self.model.id == id).first()
            if db_obj:
                obj_data = self.prepare_data_for_db(obj_in.model_dump(exclude_unset=True))
                for key, value in obj_data.items():
                    setattr(db_obj, key, value)

                db.commit()
                db.refresh(db_obj)
                return self.to_dict(db_obj)
            return None
        except Exception as e:
            db.rollback()
            logger.error(f"Error updating {self.model.__name__}: {str(e)}")
            raise

    def delete(self, db: Session, id: Any) -> Optional[Dict]:
        try:
            obj = db.query(self.model).get(id)

            if obj:
                obj_dict = self.to_dict(obj)
                db.delete(obj)
                db.commit()
                return obj_dict
            return None
        except Exception as e:
            db.rollback()
            logger.error(f"Error deleting {self.model.__name__}: {str(e)}")
            raise

    @staticmethod
    def handle_float(value: Any) -> Optional[float]:
        if value is None:
            return None
        if isinstance(value, (float, Decimal)):
            try:
                float_val = float(value)
                if math.isnan(float_val) or math.isinf(float_val):
                    return None
                return float_val
            except (ValueError, TypeError):
                return None
        return value

    def prepare_data_for_db(self, data: Dict[str, Any]) -> Dict[str, Any]:
        prepared_data = {}
        for key, value in data.items():
            if isinstance(value, (float, Decimal)):
                prepared_data[key] = self.handle_float(value)
            elif isinstance(value, list):
                prepared_data[key] = [str(item) for item in value if item] or None
            else:
                prepared_data[key] = value
        return prepared_data


class CRUDInvestor(CRUDBase[models.Investor, schemas.InvestorCreate]):
    def get_by_email(self, db: Session, email: str) -> Optional[models.Investor]:
        return db.query(models.Investor).filter(models.Investor.email == email).first()

    def get_by_industry(self, db: Session, industry: str) -> List[models.Investor]:
        return db.query(models.Investor).filter(
            models.Investor.industry_preferences.overlap([industry])
        ).all()


class CRUDInvestmentFund(CRUDBase[models.InvestmentFund, schemas.InvestmentFundCreate]):
    def get_by_firm_email(self, db: Session, firm_email: str) -> Optional[models.InvestmentFund]:
        return db.query(models.InvestmentFund).filter(
            models.InvestmentFund.firm_email == firm_email
        ).first()

    def get_by_firm_name(self, db: Session, firm_name: str) -> Optional[models.InvestmentFund]:
        return db.query(models.InvestmentFund).filter(
            models.InvestmentFund.firm_name == firm_name
        ).first()


class CRUDSavedList(CRUDBase[models.SavedList, schemas.SavedListCreate]):
    def add_investor_to_list(self, db: Session, list_id: int, investor_id: int) -> bool:
        try:
            saved_list = db.query(models.SavedList).filter(models.SavedList.id == list_id).first()
            investor = db.query(models.Investor).filter(models.Investor.id == investor_id).first()

            if saved_list and investor:
                if investor not in saved_list.saved_investors:
                    saved_list.saved_investors.append(investor)
                    db.commit()
                return True
            return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error adding investor to list: {str(e)}")
            raise

    def add_fund_to_list(self, db: Session, list_id: int, fund_id: int) -> bool:
        try:
            saved_list = db.query(models.SavedList).filter(models.SavedList.id == list_id).first()
            fund = db.query(models.InvestmentFund).filter(models.InvestmentFund.id == fund_id).first()

            if saved_list and fund:
                if fund not in saved_list.saved_funds:
                    saved_list.saved_funds.append(fund)
                    db.commit()
                return True
            return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error adding fund to list: {str(e)}")
            raise

    def remove_investor_from_list(self, db: Session, list_id: int, investor_id: int) -> bool:
        try:
            saved_list = db.query(models.SavedList).filter(models.SavedList.id == list_id).first()
            investor = db.query(models.Investor).filter(models.Investor.id == investor_id).first()

            if saved_list and investor and investor in saved_list.saved_investors:
                saved_list.saved_investors.remove(investor)
                db.commit()
                return True
            return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error removing investor from list: {str(e)}")
            raise

    def remove_fund_from_list(self, db: Session, list_id: int, fund_id: int) -> bool:
        try:
            saved_list = db.query(models.SavedList).filter(models.SavedList.id == list_id).first()
            fund = db.query(models.InvestmentFund).filter(models.InvestmentFund.id == fund_id).first()

            if saved_list and fund and fund in saved_list.saved_funds:
                saved_list.saved_funds.remove(fund)
                db.commit()
                return True
            return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error removing fund from list: {str(e)}")
            raise


# Create instances
saved_list = CRUDSavedList(models.SavedList)
investor = CRUDInvestor(models.Investor)
investment_fund = CRUDInvestmentFund(models.InvestmentFund)

================
File: database.py
================
# database.py
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, Session, declarative_base
import os
from dotenv import load_dotenv
import logging
import traceback
from fastapi import HTTPException

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig()
logger = logging.getLogger("sqlalchemy.engine")

# Get database URL from environment variables with fallback
SQLALCHEMY_DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql://investor_admin:your_secure_password@localhost/investor_db"
)
print(SQLALCHEMY_DATABASE_URL)
# Create engine with proper configuration
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    pool_pre_ping=True,  # Enable connection health checks
    pool_size=5,  # Maximum number of database connections in the pool
    max_overflow=10  # Maximum number of connections that can be created beyond pool_size
)

# Create SessionLocal class with proper configuration
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    expire_on_commit=False
)

# Create Base class for declarative models
Base = declarative_base()


async def get_db():
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logger.error(f"Database error: {str(e)}")
        db.rollback()
        raise HTTPException(
            status_code=500,
            detail="Database connection error"
        )
    finally:
        db.close()


def test_db_connection():
    """Test database connection"""
    try:
        logger.info("Testing database connection...")
        db = SessionLocal()
        db.execute(text("SELECT 1"))
        db.close()
        logger.info("Database connection successful!")
        return True
    except Exception as e:
        logger.error(f"Database connection failed: {str(e)}")
        logger.error(traceback.format_exc())
        return False

================
File: deploy.py
================
import os
import logging
from database import test_db_connection, engine
import models
from scripts.import_data import import_investors, import_investment_funds
from sqlalchemy.orm import Session

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def deploy():
    """
    Deploy application and import data
    """
    try:
        # Test database connection
        logger.info("Testing database connection...")
        if not test_db_connection():
            logger.error("Database connection failed!")
            return False

        # Create all tables
        logger.info("Creating database tables...")
        models.Base.metadata.create_all(bind=engine)

        # Import data
        logger.info("Starting data import...")
        with Session(engine) as db:
            # Check if data already exists
            investor_count = db.query(models.Investor).count()
            fund_count = db.query(models.InvestmentFund).count()

            if investor_count == 0 and fund_count == 0:
                # Import investors
                investors_csv = os.path.join('data', 'investors_cleaned.csv')
                if os.path.exists(investors_csv):
                    logger.info(f"Importing investors from {investors_csv}")
                    import_investors(investors_csv, db)
                else:
                    logger.warning(f"Investors CSV file not found: {investors_csv}")

                # Import investment funds
                funds_csv = os.path.join('data', 'vc_funds.csv')
                if os.path.exists(funds_csv):
                    logger.info(f"Importing funds from {funds_csv}")
                    import_investment_funds(funds_csv, db)
                else:
                    logger.warning(f"Investment Funds CSV file not found: {funds_csv}")
            else:
                logger.info("Data already exists in database, skipping import")

        logger.info("Deployment completed successfully!")
        return True

    except Exception as e:
        logger.error(f"Error during deployment: {str(e)}")
        return False


if __name__ == "__main__":
    deploy()

================
File: models.py
================
from sqlalchemy import Column, Integer, String, Float, Text
from sqlalchemy.dialects.postgresql import ARRAY as PG_ARRAY
from sqlalchemy.sql import func
from database import Base
from sqlalchemy import Column, Integer, String, ForeignKey, Table, DateTime
from sqlalchemy.orm import relationship
from datetime import datetime

# Association tables for many-to-many relationships
saved_investors_association = Table(
    'saved_investors_association',
    Base.metadata,
    Column('list_id', Integer, ForeignKey('saved_lists.id')),
    Column('investor_id', Integer, ForeignKey('investors.id'))
)

saved_funds_association = Table(
    'saved_funds_association',
    Base.metadata,
    Column('list_id', Integer, ForeignKey('saved_lists.id')),
    Column('fund_id', Integer, ForeignKey('investment_funds.id'))
)


class SavedList(Base):
    __tablename__ = "saved_lists"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    list_type = Column(String, nullable=False)  # 'investor' or 'fund'

    # Relationships
    saved_investors = relationship("Investor", secondary=saved_investors_association)
    saved_funds = relationship("InvestmentFund", secondary=saved_funds_association)


class Investor(Base):
    __tablename__ = "investors"

    id = Column(Integer, primary_key=True, index=True)
    prefix = Column(String, nullable=True)
    first_name = Column(String)
    last_name = Column(String)
    gender = Column(String, nullable=True)
    contact_title = Column(String, nullable=True)
    email = Column(String, unique=True, index=True)
    phone = Column(String, nullable=True)
    office_website = Column(String, nullable=True)
    firm_name = Column(String, nullable=True)
    city = Column(String, nullable=True)
    state = Column(String, nullable=True)
    country = Column(String, nullable=True)
    type_of_financing = Column(String, nullable=True)
    industry_preferences = Column(PG_ARRAY(String), nullable=True)
    geographic_preferences = Column(PG_ARRAY(String), nullable=True)
    stage_preferences = Column(PG_ARRAY(String), nullable=True)
    capital_managed = Column(Float, nullable=True)
    min_investment = Column(Float, nullable=True)
    max_investment = Column(Float, nullable=True)


class InvestmentFund(Base):
    __tablename__ = "investment_funds"

    id = Column(Integer, primary_key=True, index=True)
    full_name = Column(String)
    title = Column(String, nullable=True)
    contact_email = Column(String, index=True)
    contact_phone = Column(String, nullable=True)
    firm_name = Column(String)
    firm_email = Column(String, unique=True, index=True, nullable=True)
    firm_phone = Column(String, nullable=True)
    firm_website = Column(String, nullable=True)
    firm_address = Column(String, nullable=True)
    firm_city = Column(String, nullable=True)
    firm_state = Column(String, nullable=True)
    firm_zip = Column(String, nullable=True)
    firm_country = Column(String, nullable=True)
    office_type = Column(String, nullable=True)
    financing_type = Column(String, nullable=True)
    industry_preferences = Column(PG_ARRAY(String), nullable=True)
    geographic_preferences = Column(PG_ARRAY(String), nullable=True)
    stage_preferences = Column(PG_ARRAY(String), nullable=True)
    capital_managed = Column(Float, nullable=True)
    min_investment = Column(Float, nullable=True)
    max_investment = Column(Float, nullable=True)
    firm_type = Column(String, nullable=True)
    description = Column(Text, nullable=True)

================
File: requirements.txt
================
fastapi
uvicorn[standard]==0.24.0
sqlalchemy
psycopg2-binary==2.9.9
pydantic
python-dotenv==1.0.0
typing-extensions==4.8.0
email-validator==2.1.0.post1
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
python-multipart==0.0.18
alembic
pytest==7.4.3
httpx==0.25.1
pandas~=2.2.3
PyJWT

================
File: schemas.py
================
from enum import Enum
from typing import Optional, List
from pydantic import BaseModel, ConfigDict
from datetime import datetime
from database import Base
from sqlalchemy import Column, Integer, String, Float, Text
from sqlalchemy.dialects.postgresql import ARRAY as PG_ARRAY


###########################################
# Investment Fund Filter Enums
###########################################

class InvestmentFundCity(str, Enum):
    NEW_YORK = "New York"
    LONDON = "London"
    SAN_FRANCISCO = "San Francisco"
    CHICAGO = "Chicago"
    BOSTON = "Boston"
    PARIS = "Paris"
    PALO_ALTO = "Palo Alto"
    SHANGHAI = "Shanghai"
    TORONTO = "Toronto"
    MENLO_PARK = "Menlo Park"
    DALLAS = "Dallas"
    TOKYO = "Tokyo"
    BEIJING = "Beijing"
    LOS_ANGELES = "Los Angeles"
    HOUSTON = "Houston"
    MUNICH = "Munich"
    STOCKHOLM = "Stockholm"
    MUMBAI = "Mumbai"
    CAMBRIDGE = "Cambridge"
    AUSTIN = "Austin"


class InvestmentFundState(str, Enum):
    CALIFORNIA = "California"
    NEW_YORK = "New York"
    MASSACHUSETTS = "Massachusetts"
    TEXAS = "Texas"
    ILLINOIS = "Illinois"
    ONTARIO = "Ontario"
    CONNECTICUT = "Connecticut"
    FLORIDA = "Florida"
    PENNSYLVANIA = "Pennsylvania"
    COLORADO = "Colorado"
    MICHIGAN = "Michigan"
    OHIO = "Ohio"
    GEORGIA = "Georgia"
    MARYLAND = "Maryland"
    VIRGINIA = "Virginia"
    NEW_SOUTH_WALES = "New South Wales"
    NORTH_CAROLINA = "North Carolina"
    WASHINGTON = "Washington"
    BRITISH_COLUMBIA = "British Columbia"
    NEW_JERSEY = "New Jersey"


class InvestmentFundCountry(str, Enum):
    UNITED_STATES = "United States"
    UNITED_KINGDOM = "United Kingdom"
    GERMANY = "Germany"
    CANADA = "Canada"
    CHINA = "China"
    FRANCE = "France"
    INDIA = "India"
    ISRAEL = "Israel"
    HONG_KONG = "Hong Kong"
    JAPAN = "Japan"
    SINGAPORE = "Singapore"
    SWEDEN = "Sweden"
    AUSTRALIA = "Australia"
    NETHERLANDS = "Netherlands"
    SPAIN = "Spain"
    BELGIUM = "Belgium"
    SWITZERLAND = "Switzerland"
    FINLAND = "Finland"
    ITALY = "Italy"
    KOREA = "Korea"


class InvestmentFundLocationPreference(str, Enum):
    UNITED_STATES = "United States"
    EUROPE = "Europe"
    CANADA = "Canada"
    UNITED_KINGDOM = "United Kingdom"
    CHINA = "China"
    GERMANY = "Germany"
    UNITED_STATES_CALIFORNIA = "United States (California)"
    ASIA = "Asia"
    FRANCE = "France"
    UNITED_STATES_MID_ATLANTIC = "United States (Mid-Atlantic)"
    UNITED_STATES_MIDWEST = "United States (Midwest)"
    ISRAEL = "Israel"
    UNITED_STATES_SOUTHWEST = "United States (Southwest)"
    UNITED_STATES_SOUTHEAST = "United States (Southeast)"
    UNITED_STATES_NORTHEAST = "United States (Northeast)"
    SWITZERLAND = "Switzerland"
    SWEDEN = "Sweden"
    INDIA = "India"
    NETHERLANDS = "Netherlands"
    AUSTRALIA = "Australia"


class InvestmentFundIndustryPreference(str, Enum):
    IT_SERVICES = "IT Services"
    COMMUNICATIONS_NETWORKING = "Communications & Networking"
    SOFTWARE = "Software"
    HEALTHCARE_SERVICES = "Healthcare Services"
    CONSUMER_PRODUCTS_SERVICES = "Consumer Products & Services"
    BUSINESS_PRODUCTS_SERVICES = "Business Products & Services"
    MEDIA_ENTERTAINMENT = "Media & Entertainment"
    DISTRIBUTION_RETAIL = "Distribution/Retailing"
    FINANCIAL_SERVICES = "Financial Services"
    ENERGY_NATURAL_RESOURCES = "Energy/Natural Resources"
    DIVERSIFIED = "Diversified"
    INTERNET_TECHNOLOGY = "Internet Technology"
    CHEMICALS_MATERIALS = "Chemicals & Materials"
    MANUFACTURING = "Manufacturing"
    BIOTECHNOLOGY = "Biotechnology"
    ELECTRONICS = "Electronics"
    MEDICAL_DEVICES_EQUIPMENT = "Medical Devices & Equipment"
    INDUSTRIAL_PRODUCTS_SERVICES = "Industrial Products & Services"
    FOOD_SERVICES_PRODUCTS = "Food Services & Products"
    ENVIRONMENT = "Environment"


class InvestmentFundType(str, Enum):
    PRIVATE_EQUITY = "Private Equity Fund"
    VENTURE_CAPITAL = "Venture Capital Fund"
    INVESTMENT_BANK = "Investment Bank"
    SMALL_BUSINESS = "Small Business Investment Company"
    STARTUP_STUDIO = "Startup Studio"
    GOVERNMENT = "Government Organization"


class InvestmentFundStagePreference(str, Enum):
    EXPANSION = "Expansion"
    MBO_LBO = "MBO/LBO"
    EARLY_STAGE = "Early Stage"
    STARTUP = "Startup"
    SEED = "Seed"
    ACQUISITION = "Acquisition"
    RECAPITALIZATION = "Recapitalization"
    LATER_STAGE = "Later Stage"
    RESTRUCTURING = "Restructuring"
    CORPORATE_DIVESTITURE = "Corporate Divestiture"
    CONSOLIDATION = "Consolidation"
    GOING_PRIVATE = "Going Private"
    SPECIAL_SITUATIONS = "Special Situations"
    TURNAROUND = "Turnaround"
    PIPE = "PIPE"
    SPINOUT = "Spinout"
    SECONDARY_PURCHASE = "Secondary Purchase"
    OWNERSHIP_TRANSITION = "Ownership Transition"
    DISTRESSED_DEBT = "Distressed Debt"
    PRIVATIZATION = "Privatization"


class InvestmentFundAssetsUnderManagement(str, Enum):
    TIER_1B_PLUS = "$1B+"
    TIER_100M_500M = "$100M - $500M"
    TIER_500M_1B = "$500M - $1B"
    TIER_25M_100M = "$25M - $100M"
    TIER_0_25M = "$0 - $25M"


class InvestmentFundMinInvestment(str, Enum):
    TIER_5M_20M = "$5M - $20M"
    TIER_1M_5M = "$1M - $5M"
    TIER_250K_1M = "$250K - $1M"
    TIER_20M_PLUS = "$20M+"
    TIER_0_250K = "$0 - $250K"


class InvestmentFundMaxInvestment(str, Enum):
    TIER_1M_10M = "$1M - $10M"
    TIER_10M_25M = "$10M - $25M"
    TIER_25M_100M = "$25M - $100M"
    TIER_100M_PLUS = "$100M+"
    TIER_0_1M = "$0 - $1M"


class InvestmentFundNumberOfInvestors(str, Enum):
    TIER_1_10 = "1 - 10"
    TIER_10_20 = "10 - 20"
    TIER_20_30 = "20 - 30"
    TIER_30_40 = "30 - 40"


class InvestmentFundGenderRatio(str, Enum):
    NO_FEMALE = "0% female"
    FEMALE_25 = "25% female"
    FEMALE_20 = "20% female"
    FEMALE_33 = "33% female"
    FEMALE_17 = "17% female"
    FEMALE_13 = "13% female"
    FEMALE_50 = "50% female"
    FEMALE_14 = "14% female"
    FEMALE_11 = "11% female"
    FEMALE_8 = "8% female"
    FEMALE_9 = "9% female"
    FEMALE_10 = "10% female"
    FEMALE_6 = "6% female"
    FEMALE_100 = "100% female"
    FEMALE_40 = "40% female"
    FEMALE_29 = "29% female"
    FEMALE_22 = "22% female"
    FEMALE_7 = "7% female"
    FEMALE_15 = "15% female"
    FEMALE_4 = "4% female"


###########################################


# Investor Filter Enums
###########################################

class InvestorCity(str, Enum):
    NEW_YORK = "New York"
    LONDON = "London"
    SAN_FRANCISCO = "San Francisco"
    CHICAGO = "Chicago"
    BOSTON = "Boston"
    PARIS = "Paris"
    TORONTO = "Toronto"
    PALO_ALTO = "Palo Alto"
    SHANGHAI = "Shanghai"
    MENLO_PARK = "Menlo Park"
    DALLAS = "Dallas"
    LOS_ANGELES = "Los Angeles"
    HOUSTON = "Houston"
    STOCKHOLM = "Stockholm"
    MUNICH = "Munich"
    AMSTERDAM = "Amsterdam"
    BEIJING = "Beijing"
    GREENWICH = "Greenwich"
    MUMBAI = "Mumbai"
    TOKYO = "Tokyo"


class InvestorState(str, Enum):
    CALIFORNIA = "California"
    NEW_YORK = "New York"
    MASSACHUSETTS = "Massachusetts"
    ILLINOIS = "Illinois"
    TEXAS = "Texas"
    CONNECTICUT = "Connecticut"
    ONTARIO = "Ontario"
    PENNSYLVANIA = "Pennsylvania"
    FLORIDA = "Florida"
    NORTH_CAROLINA = "North Carolina"
    COLORADO = "Colorado"
    MARYLAND = "Maryland"
    MICHIGAN = "Michigan"
    NEW_SOUTH_WALES = "New South Wales"
    GEORGIA = "Georgia"
    OHIO = "Ohio"
    VIRGINIA = "Virginia"
    MINNESOTA = "Minnesota"
    DISTRICT_OF_COLUMBIA = "District of Columbia"
    MISSOURI = "Missouri"


class InvestorCountry(str, Enum):
    UNITED_STATES = "United States"
    UNITED_KINGDOM = "United Kingdom"
    FRANCE = "France"
    GERMANY = "Germany"
    CANADA = "Canada"
    CHINA = "China"
    NETHERLANDS = "Netherlands"
    INDIA = "India"
    SWEDEN = "Sweden"
    ISRAEL = "Israel"
    SPAIN = "Spain"
    AUSTRALIA = "Australia"
    SINGAPORE = "Singapore"
    BELGIUM = "Belgium"
    FINLAND = "Finland"
    JAPAN = "Japan"
    HONG_KONG = "Hong Kong"
    ITALY = "Italy"
    SWITZERLAND = "Switzerland"
    NORWAY = "Norway"


class InvestorLocationPreference(str, Enum):
    UNITED_STATES = "United States"
    EUROPE = "Europe"
    CANADA = "Canada"
    UNITED_KINGDOM = "United Kingdom"
    GERMANY = "Germany"
    CHINA = "China"
    FRANCE = "France"
    UNITED_STATES_CALIFORNIA = "United States (California)"
    ASIA = "Asia"
    UNITED_STATES_MID_ATLANTIC = "United States (Mid-Atlantic)"
    UNITED_STATES_MIDWEST = "United States (Midwest)"
    UNITED_STATES_SOUTHEAST = "United States (Southeast)"
    ISRAEL = "Israel"
    SWITZERLAND = "Switzerland"
    UNITED_STATES_SOUTHWEST = "United States (Southwest)"
    NETHERLANDS = "Netherlands"
    SWEDEN = "Sweden"
    UNITED_STATES_NORTHEAST = "United States (Northeast)"
    FINLAND = "Finland"
    AUSTRIA = "Austria"


class InvestorIndustryPreference(str, Enum):
    IT_SERVICES = "IT Services"
    COMMUNICATIONS_NETWORKING = "Communications & Networking"
    HEALTHCARE_SERVICES = "Healthcare Services"
    BUSINESS_PRODUCTS_SERVICES = "Business Products & Services"
    CONSUMER_PRODUCTS_SERVICES = "Consumer Products & Services"
    DISTRIBUTION_RETAIL = "Distribution/Retailing"
    FINANCIAL_SERVICES = "Financial Services"
    SOFTWARE = "Software"
    DIVERSIFIED = "Diversified"
    MEDIA_ENTERTAINMENT = "Media & Entertainment"
    ENERGY_NATURAL_RESOURCES = "Energy/Natural Resources"
    MANUFACTURING = "Manufacturing"
    INTERNET_TECHNOLOGY = "Internet Technology"
    CHEMICALS_MATERIALS = "Chemicals & Materials"
    INDUSTRIAL_PRODUCTS_SERVICES = "Industrial Products & Services"
    ELECTRONICS = "Electronics"
    BIOTECHNOLOGY = "Biotechnology"
    MEDICAL_DEVICES_EQUIPMENT = "Medical Devices & Equipment"
    FOOD_SERVICES_PRODUCTS = "Food Services & Products"
    EDUCATION_TRAINING = "Education & Training"


class InvestorFundType(str, Enum):
    PRIVATE_EQUITY = "Private Equity Fund"
    VENTURE_CAPITAL = "Venture Capital Fund"
    SMALL_BUSINESS = "Small Business Investment Company"
    INVESTMENT_BANK = "Investment Bank"
    GOVERNMENT = "Government Organization"
    STARTUP_STUDIO = "Startup Studio"


class InvestorStagePreference(str, Enum):
    EXPANSION = "Expansion"
    MBO_LBO = "MBO/LBO"
    EARLY_STAGE = "Early Stage"
    STARTUP = "Startup"
    SEED = "Seed"
    RECAPITALIZATION = "Recapitalization"
    ACQUISITION = "Acquisition"
    LATER_STAGE = "Later Stage"
    CORPORATE_DIVESTITURE = "Corporate Divestiture"
    RESTRUCTURING = "Restructuring"
    CONSOLIDATION = "Consolidation"
    GOING_PRIVATE = "Going Private"
    SPECIAL_SITUATIONS = "Special Situations"
    TURNAROUND = "Turnaround"
    PIPE = "PIPE"
    SPINOUT = "Spinout"
    OWNERSHIP_TRANSITION = "Ownership Transition"
    SECONDARY_PURCHASE = "Secondary Purchase"
    PRIVATIZATION = "Privatization"
    DISTRESSED_DEBT = "Distressed Debt"


class InvestorAssetsUnderManagement(str, Enum):
    TIER_1B_PLUS = "$1B+"
    TIER_100M_500M = "$100M - $500M"
    TIER_500M_1B = "$500M - $1B"
    TIER_25M_100M = "$25M - $100M"
    TIER_0_25M = "$0 - $25M"


class InvestorMinInvestment(str, Enum):
    TIER_5M_20M = "$5M - $20M"
    TIER_20M_PLUS = "$20M+"
    TIER_1M_5M = "$1M - $5M"
    TIER_250K_1M = "$250K - $1M"
    TIER_0_250K = "$0 - $250K"


class InvestorMaxInvestment(str, Enum):
    TIER_25M_100M = "$25M - $100M"
    TIER_10M_25M = "$10M - $25M"
    TIER_100M_PLUS = "$100M+"
    TIER_1M_10M = "$1M - $10M"
    TIER_0_1M = "$0 - $1M"


class InvestorNumberOfInvestors(str, Enum):
    TIER_1_10 = "1 - 10"
    TIER_10_20 = "10 - 20"
    TIER_20_30 = "20 - 30"
    TIER_30_40 = "30 - 40"


class InvestorJobTitle(str, Enum):
    PARTNER = "Partner"
    MANAGING_DIRECTOR = "Managing Director"
    MANAGING_PARTNER = "Managing Partner"
    ASSOCIATE = "Associate"
    PRINCIPAL = "Principal"
    VICE_PRESIDENT = "Vice President"
    SENIOR_ASSOCIATE = "Senior Associate"
    GENERAL_PARTNER = "General Partner"
    INVESTMENT_MANAGER = "Investment Manager"
    INVESTMENT_DIRECTOR = "Investment Director"
    DIRECTOR = "Director"
    CFO = "CFO"
    ANALYST = "Analyst"
    CEO = "CEO"
    FOUNDING_PARTNER = "Founding Partner"
    VENTURE_PARTNER = "Venture Partner"
    OPERATING_PARTNER = "Operating Partner"
    PRESIDENT = "President"
    CHAIRMAN = "Chairman"
    SENIOR_MANAGING_DIRECTOR = "Senior Managing Director"


class InvestorGender(str, Enum):
    MALE = "Male"  # 31,454
    FEMALE = "Female"  # 4,572


###########################################
# Filter Parameters Models
###########################################

class LocationFilter(BaseModel):
    """Location filter parameters"""
    city: Optional[List[str]] = None
    state: Optional[List[str]] = None
    country: Optional[List[str]] = None
    location_preferences: Optional[List[str]] = None


class ContactInfoFilter(BaseModel):
    """Contact information filter parameters"""
    hasEmail: Optional[bool] = None
    hasPhone: Optional[bool] = None
    hasAddress: Optional[bool] = None


class IndustryFilter(BaseModel):
    """Industry preferences filter parameters"""
    industries: Optional[List[str]] = None


class StagePreferencesFilter(BaseModel):
    """Investment stage preferences filter parameters"""
    stages: Optional[List[str]] = None


class FundTypeFilter(BaseModel):
    """Fund type filter parameters"""
    types: Optional[List[str]] = None


class InvestmentRangesFilter(BaseModel):
    """Investment range filter parameters"""
    assetsUnderManagement: Optional[str] = None
    minInvestment: Optional[str] = None
    maxInvestment: Optional[str] = None


class InvestorCountFilter(BaseModel):
    """Number of investors filter parameters"""
    range: Optional[str] = None


class GenderRatioFilter(BaseModel):
    """Gender ratio filter parameters"""
    ratio: Optional[str] = None


class GenderFilter(BaseModel):
    """Gender filter parameters"""
    gender: Optional[str] = None


class JobTitleFilter(BaseModel):
    """Job title filter parameters"""
    titles: Optional[List[str]] = None


# Main filter parameter models
class InvestorFilterParams(BaseModel):
    """Complete investor filter parameters"""
    searchTerm: Optional[str] = None
    location: Optional[LocationFilter] = None
    contactInfo: Optional[ContactInfoFilter] = None
    industry: Optional[IndustryFilter] = None
    fundType: Optional[FundTypeFilter] = None
    stages: Optional[StagePreferencesFilter] = None
    investmentRanges: Optional[InvestmentRangesFilter] = None
    jobTitle: Optional[JobTitleFilter] = None
    gender: Optional[GenderFilter] = None

    class Config:
        use_enum_values = True


###########################################
# Base Models
###########################################

class InvestorBase(BaseModel):  # Changed from Base to BaseModel
    prefix: Optional[str] = None
    first_name: str
    last_name: str
    gender: Optional[str] = None
    contact_title: Optional[str] = None
    email: str
    phone: Optional[str] = None
    office_website: Optional[str] = None
    firm_name: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    country: Optional[str] = None
    type_of_financing: Optional[str] = None
    industry_preferences: Optional[List[str]] = None
    geographic_preferences: Optional[List[str]] = None
    stage_preferences: Optional[List[str]] = None
    capital_managed: Optional[float] = None
    min_investment: Optional[float] = None
    max_investment: Optional[float] = None


class InvestorCreate(InvestorBase):
    pass


class Investor(InvestorBase):
    id: int

    model_config = ConfigDict(from_attributes=True)


class InvestmentFundBase(BaseModel):  # Changed from Base to BaseModel
    full_name: str
    title: Optional[str] = None
    contact_email: str
    contact_phone: Optional[str] = None
    firm_name: str
    firm_email: Optional[str] = None
    firm_phone: Optional[str] = None
    firm_website: Optional[str] = None
    firm_address: Optional[str] = None
    firm_city: Optional[str] = None
    firm_state: Optional[str] = None
    firm_zip: Optional[str] = None
    firm_country: Optional[str] = None
    office_type: Optional[str] = None
    financing_type: Optional[str] = None
    industry_preferences: Optional[List[str]] = None
    geographic_preferences: Optional[List[str]] = None
    stage_preferences: Optional[List[str]] = None
    capital_managed: Optional[float] = None
    min_investment: Optional[float] = None
    max_investment: Optional[float] = None
    firm_type: Optional[str] = None

    description: Optional[str] = None


class InvestmentFundCreate(InvestmentFundBase):
    pass


class InvestmentFund(InvestmentFundBase):
    id: int
    model_config = ConfigDict(
        from_attributes=True,
        json_encoders={float: lambda v: v if v is not None else None}
    )


class InvestmentFundFilterParams(BaseModel):
    """Complete investment fund filter parameters"""
    searchTerm: Optional[str] = None
    location: Optional[LocationFilter] = None
    contactInfo: Optional[ContactInfoFilter] = None
    industry: Optional[IndustryFilter] = None
    fundType: Optional[FundTypeFilter] = None
    stages: Optional[StagePreferencesFilter] = None
    investmentRanges: Optional[InvestmentRangesFilter] = None
    investorCount: Optional[InvestorCountFilter] = None
    genderRatio: Optional[GenderRatioFilter] = None

    class Config:
        use_enum_values = True


class SavedListBase(BaseModel):
    """Base class for saved lists"""
    name: str
    description: Optional[str] = None
    list_type: str  # 'investor' or 'fund'


class SavedListCreate(SavedListBase):
    """Create schema for saved lists"""
    pass


class SavedList(SavedListBase):
    """Response schema for saved lists"""
    id: int
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)
